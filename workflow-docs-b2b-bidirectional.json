{
  "name": "PhotoCertif B2B - Bidirectional Complete Automation",
  "nodes": [
    {
      "parameters": {},
      "id": "manual-trigger",
      "name": "When clicking 'Test workflow'",
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [240, 500]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "file",
              "name": "fileUrl",
              "value": "https://drive.google.com/uc?id=YOUR_FILE_ID&export=download",
              "type": "string"
            },
            {
              "id": "title",
              "name": "title",
              "value": "B2B Automated Contract 2025",
              "type": "string"
            },
            {
              "id": "desc",
              "name": "description",
              "value": "Complete bidirectional automation test",
              "type": "string"
            },
            {
              "id": "name",
              "name": "cert_name",
              "value": "AutoContract2025",
              "type": "string"
            },
            {
              "id": "symbol",
              "name": "cert_symbol",
              "value": "AUTO",
              "type": "string"
            },
            {
              "id": "certdesc",
              "name": "cert_description",
              "value": "Automated B2B certification with bidirectional flow",
              "type": "string"
            },
            {
              "id": "owner",
              "name": "cert_owner",
              "value": "B2B Client Corp",
              "type": "string"
            }
          ]
        }
      },
      "id": "input-data",
      "name": "Input Data",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [460, 500]
    },
    {
      "parameters": {
        "resourceType": "docs",
        "operation": "getPricing"
      },
      "id": "get-pricing",
      "name": "1. Get Pricing",
      "type": "n8n-nodes-photocertif.photoCertif",
      "typeVersion": 1,
      "position": [680, 500],
      "credentials": {
        "photoCertifApi": {
          "id": "1",
          "name": "PhotoCertif API"
        }
      }
    },
    {
      "parameters": {
        "resourceType": "docs",
        "operation": "upload",
        "inputType": "url",
        "fileUrl": "={{ $('Input Data').item.json.fileUrl }}",
        "title": "={{ $('Input Data').item.json.title }}",
        "description": "={{ $('Input Data').item.json.description }}"
      },
      "id": "upload",
      "name": "2. Upload Document",
      "type": "n8n-nodes-photocertif.photoCertif",
      "typeVersion": 1,
      "position": [900, 500],
      "credentials": {
        "photoCertifApi": {
          "id": "1",
          "name": "PhotoCertif API"
        }
      }
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('1. Get Pricing').item.json.base_url || 'https://localhost' }}/api/storage/docs/prepare-certification",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "photoCertifApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"storage_id\": \"{{ $('2. Upload Document').item.json.storage_id }}\",\n  \"cert_data\": {\n    \"name\": \"{{ $('Input Data').item.json.cert_name }}\",\n    \"cert_symbol\": \"{{ $('Input Data').item.json.cert_symbol }}\",\n    \"cert_description\": \"{{ $('Input Data').item.json.cert_description }}\",\n    \"cert_prop\": \"{{ $('Input Data').item.json.cert_owner }}\"\n  }\n}",
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "id": "prepare",
      "name": "3. Prepare Certification (Server)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1120, 500],
      "credentials": {
        "photoCertifApi": {
          "id": "1",
          "name": "PhotoCertif API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// STEP 4: AUTO-SWAP + PAYMENT\n// ============================================\n// Same as before: check balance, swap if needed, pay\n\nconst { Connection, Keypair, PublicKey, VersionedTransaction, Transaction } = require('@solana/web3.js');\nconst { getAssociatedTokenAddress, createTransferInstruction, getAccount } = require('@solana/spl-token');\nconst bs58 = require('bs58');\nconst fetch = require('node-fetch');\n\nconst pricingData = $('1. Get Pricing').first().json;\nconst uploadData = $('2. Upload Document').first().json;\n\nconst RPC_URL = 'https://api.mainnet-beta.solana.com';\nconst JUPITER_API = 'https://quote-api.jup.ag/v6';\nconst SOL_MINT = 'So11111111111111111111111111111111111111112';\nconst CHECKHC_MINT = pricingData.checkhc_mint;\nconst PAYMENT_WALLET = new PublicKey(pricingData.payment_wallet);\nconst AMOUNT_CHECKHC_NEEDED = pricingData.price_checkhc;\nconst SLIPPAGE_BPS = 100;\n\nconst credentials = await this.getCredentials('solanaWallet');\nconst privateKeyBase58 = credentials.privateKey;\nconst payerKeypair = Keypair.fromSecretKey(bs58.decode(privateKeyBase58));\n\nconsole.log('\\n🚀 SWAP + PAYMENT');\nconst connection = new Connection(RPC_URL, 'confirmed');\n\nconst checkhcMint = new PublicKey(CHECKHC_MINT);\nconst checkhcTokenAccount = await getAssociatedTokenAddress(checkhcMint, payerKeypair.publicKey);\n\nlet currentCHECKHCBalance = 0;\ntry {\n  const accountInfo = await getAccount(connection, checkhcTokenAccount);\n  currentCHECKHCBalance = Number(accountInfo.amount) / 1000000;\n  console.log('Current CHECKHC:', currentCHECKHCBalance);\n} catch (error) {\n  console.log('No CHECKHC account yet');\n}\n\nconst checkhcDeficit = Math.max(0, AMOUNT_CHECKHC_NEEDED - currentCHECKHCBalance);\n\nlet swapSignature = null;\nlet solSpent = 0;\nlet checkhcReceived = 0;\n\nif (checkhcDeficit > 0) {\n  console.log('🔄 Swapping', checkhcDeficit, 'CHECKHC');\n  \n  const outputAmountRaw = Math.ceil(checkhcDeficit * 1000000);\n  const quoteUrl = `${JUPITER_API}/quote?inputMint=${SOL_MINT}&outputMint=${CHECKHC_MINT}&amount=${outputAmountRaw}&slippageBps=${SLIPPAGE_BPS}&swapMode=ExactOut`;\n  \n  const quoteResponse = await fetch(quoteUrl);\n  if (!quoteResponse.ok) throw new Error('Jupiter quote failed');\n  \n  const quoteData = await quoteResponse.json();\n  const solNeeded = Number(quoteData.inAmount) / 1000000000;\n  \n  console.log('SOL needed:', solNeeded);\n  \n  const solBalance = await connection.getBalance(payerKeypair.publicKey);\n  if (solBalance / 1000000000 < solNeeded + 0.01) {\n    throw new Error(`Insufficient SOL. Need ${solNeeded + 0.01}`);\n  }\n  \n  const swapResponse = await fetch(`${JUPITER_API}/swap`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      quoteResponse: quoteData,\n      userPublicKey: payerKeypair.publicKey.toString(),\n      wrapAndUnwrapSol: true,\n      dynamicComputeUnitLimit: true,\n      prioritizationFeeLamports: 'auto'\n    })\n  });\n  \n  if (!swapResponse.ok) throw new Error('Swap transaction failed');\n  \n  const swapData = await swapResponse.json();\n  const swapTransactionBuf = Buffer.from(swapData.swapTransaction, 'base64');\n  let transaction = VersionedTransaction.deserialize(swapTransactionBuf);\n  transaction.sign([payerKeypair]);\n  \n  swapSignature = await connection.sendRawTransaction(transaction.serialize(), {\n    skipPreflight: false,\n    maxRetries: 3\n  });\n  \n  const latestBlockhash = await connection.getLatestBlockhash('confirmed');\n  await connection.confirmTransaction({\n    signature: swapSignature,\n    blockhash: latestBlockhash.blockhash,\n    lastValidBlockHeight: latestBlockhash.lastValidBlockHeight\n  }, 'confirmed');\n  \n  const newAccountInfo = await getAccount(connection, checkhcTokenAccount);\n  const newBalance = Number(newAccountInfo.amount) / 1000000;\n  \n  solSpent = solNeeded;\n  checkhcReceived = newBalance - currentCHECKHCBalance;\n  currentCHECKHCBalance = newBalance;\n  \n  console.log('✅ Swap complete. New balance:', currentCHECKHCBalance);\n} else {\n  console.log('✅ Sufficient CHECKHC');\n}\n\n// Payment\nconsole.log('💳 Paying certification...');\n\nconst paymentTokenAccount = await getAssociatedTokenAddress(checkhcMint, PAYMENT_WALLET);\nconst amountRaw = Math.floor(AMOUNT_CHECKHC_NEEDED * 1000000);\nconst transferIx = createTransferInstruction(\n  checkhcTokenAccount,\n  paymentTokenAccount,\n  payerKeypair.publicKey,\n  amountRaw\n);\n\nconst { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash('confirmed');\nconst paymentTx = new Transaction();\npaymentTx.recentBlockhash = blockhash;\npaymentTx.feePayer = payerKeypair.publicKey;\npaymentTx.add(transferIx);\npaymentTx.sign(payerKeypair);\n\nconst paymentSignature = await connection.sendRawTransaction(\n  paymentTx.serialize(),\n  { skipPreflight: false, preflightCommitment: 'confirmed' }\n);\n\nawait connection.confirmTransaction({\n  signature: paymentSignature,\n  blockhash,\n  lastValidBlockHeight\n}, 'confirmed');\n\nconsole.log('✅ Payment confirmed!\\n');\n\nreturn {\n  swap_executed: checkhcDeficit > 0,\n  swap_signature: swapSignature,\n  sol_spent: solSpent,\n  checkhc_received: checkhcReceived,\n  payment_signature: paymentSignature,\n  payment_amount: AMOUNT_CHECKHC_NEEDED,\n  payer_wallet: payerKeypair.publicKey.toString(),\n  storage_id: uploadData.storage_id\n};"
      },
      "id": "swap-pay",
      "name": "4. Swap + Pay",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 500]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('1. Get Pricing').item.json.base_url || 'https://localhost' }}/api/storage/docs/execute-irys-upload",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "photoCertifApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"storage_id\": \"{{ $('2. Upload Document').item.json.storage_id }}\",\n  \"user_private_key\": \"{{ $credentials.solanaWallet.privateKey }}\"\n}",
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "id": "irys-upload",
      "name": "5. Execute Irys Upload (Server)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1560, 500],
      "credentials": {
        "photoCertifApi": {
          "id": "1",
          "name": "PhotoCertif API"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// ============================================\n// STEP 6: MINT NFT (n8n/Client-side)\n// ============================================\n// n8n mints the NFT using metadata from server\n\nconst { Connection, Keypair, PublicKey } = require('@solana/web3.js');\nconst { createUmi } = require('@metaplex-foundation/umi-bundle-defaults');\nconst { keypairIdentity } = require('@metaplex-foundation/umi');\nconst { createNft } = require('@metaplex-foundation/mpl-token-metadata');\nconst bs58 = require('bs58');\n\nconst irysData = $('5. Execute Irys Upload (Server)').first().json;\nconst metadata = irysData.metadata_for_nft;\n\nconst RPC_URL = 'https://api.mainnet-beta.solana.com';\n\nconst credentials = await this.getCredentials('solanaWallet');\nconst privateKeyBase58 = credentials.privateKey;\nconst payerKeypair = Keypair.fromSecretKey(bs58.decode(privateKeyBase58));\n\nconsole.log('\\n🎨 MINTING NFT');\nconsole.log('Using metadata URI:', irysData.irys_urls.metadata);\n\n// Create Umi instance\nconst umi = createUmi(RPC_URL);\nconst umiKeypair = umi.eddsa.createKeypairFromSecretKey(payerKeypair.secretKey);\numi.use(keypairIdentity(umiKeypair));\n\nconsole.log('Creating NFT...');\n\n// Mint NFT\nconst result = await createNft(umi, {\n  mint: umi.eddsa.generateKeypair(),\n  name: metadata.name,\n  symbol: metadata.symbol,\n  uri: irysData.irys_urls.metadata, // Use Irys metadata URL\n  sellerFeeBasisPoints: 0,\n  creators: metadata.properties.creators.map(c => ({\n    address: c.address,\n    share: c.share,\n    verified: false\n  }))\n}).sendAndConfirm(umi);\n\nconst mintAddress = result.result.value.mint.toString();\nconst signature = bs58.encode(result.signature);\n\nconsole.log('✅ NFT Minted!');\nconsole.log('Mint:', mintAddress);\nconsole.log('Signature:', signature);\n\nreturn {\n  nft_mint_address: mintAddress,\n  mint_transaction_signature: signature,\n  owner_wallet: payerKeypair.publicKey.toString(),\n  storage_id: irysData.storage_id,\n  metadata_url: irysData.irys_urls.metadata,\n  image_url: irysData.irys_urls.certified_image,\n  original_url: irysData.irys_urls.original_document\n};"
      },
      "id": "mint-nft",
      "name": "6. Mint NFT (n8n)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 500]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $('1. Get Pricing').item.json.base_url || 'https://localhost' }}/api/storage/docs/finalize-certification",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "photoCertifApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"storage_id\": \"{{ $('6. Mint NFT (n8n)').item.json.storage_id }}\",\n  \"nft_mint_address\": \"{{ $('6. Mint NFT (n8n)').item.json.nft_mint_address }}\",\n  \"mint_transaction_signature\": \"{{ $('6. Mint NFT (n8n)').item.json.mint_transaction_signature }}\",\n  \"owner_wallet\": \"{{ $('6. Mint NFT (n8n)').item.json.owner_wallet }}\"\n}",
        "options": {
          "allowUnauthorizedCerts": true
        }
      },
      "id": "finalize",
      "name": "7. Finalize (Server)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2000, 500],
      "credentials": {
        "photoCertifApi": {
          "id": "1",
          "name": "PhotoCertif API"
        }
      }
    },
    {
      "parameters": {
        "content": "=## 🎉 COMPLETE BIDIRECTIONAL AUTOMATION\n\n**100% Automated - Server + n8n collaboration!**\n\n---\n\n## 📋 Workflow Steps\n\n✅ **1. Get Pricing** - Server API\n✅ **2. Upload** - Server stores file\n✅ **3. Prepare** - Server prepares metadata\n✅ **4. Swap + Pay** - n8n (user wallet)\n✅ **5. Irys Upload** - Server with user wallet\n✅ **6. Mint NFT** - n8n (user wallet)\n✅ **7. Finalize** - Server records completion\n\n---\n\n## 💰 Payment\n{{ $('4. Swap + Pay').item.json.swap_executed ? '**Swap:** ✅ ' + $('4. Swap + Pay').item.json.sol_spent + ' SOL → ' + $('4. Swap + Pay').item.json.checkhc_received + ' CHECKHC' : '**Swap:** ⏭️ Skipped (sufficient balance)' }}\n**Payment:** {{ $('4. Swap + Pay').item.json.payment_amount }} CHECKHC\n**TX:** {{ $('4. Swap + Pay').item.json.payment_signature }}\n\n---\n\n## 🌐 Irys Upload\n**Image:** {{ $('5. Execute Irys Upload (Server)').item.json.irys_urls.certified_image }}\n**Original:** {{ $('5. Execute Irys Upload (Server)').item.json.irys_urls.original_document }}\n**Metadata:** {{ $('5. Execute Irys Upload (Server)').item.json.irys_urls.metadata }}\n\n---\n\n## 🎨 NFT Minted\n**Mint Address:** {{ $('6. Mint NFT (n8n)').item.json.nft_mint_address }}\n**Owner:** {{ $('6. Mint NFT (n8n)').item.json.owner_wallet }}\n**TX:** {{ $('6. Mint NFT (n8n)').item.json.mint_transaction_signature }}\n\n**Solscan:** {{ $('7. Finalize (Server)').item.json.explorer_links.nft }}\n\n---\n\n## ✅ CERTIFICATION COMPLETE!\n\n**Status:** {{ $('7. Finalize (Server)').item.json.certification_data.status }}\n**Storage ID:** {{ $('7. Finalize (Server)').item.json.storage_id }}\n\n**Total Time:** ~90-120 seconds\n**User Provided:** SOL only 🚀\n**Server Did:** File processing, Irys upload, validation\n**n8n Did:** Swap, payment, NFT mint",
        "height": 900,
        "width": 600,
        "color": 4
      },
      "id": "results",
      "name": "Results - Complete Automation",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [2240, 200]
    },
    {
      "parameters": {
        "content": "=## ⚡ BIDIRECTIONAL ARCHITECTURE\n\n### 🏗️ Server Responsibilities:\n- ✅ File storage & processing\n- ✅ AI analysis & PRNU\n- ✅ Metadata preparation\n- ✅ Irys uploads (with user wallet)\n- ✅ Transaction verification\n- ✅ Database updates\n\n### 👤 n8n (User) Responsibilities:\n- ✅ Holds private key (NEVER sent to server permanently)\n- ✅ SOL → CHECKHC swap via Jupiter\n- ✅ Payment to PhotoCertif\n- ✅ Signs Irys transactions\n- ✅ Mints NFT\n\n### 🔐 Security:\n- Private key passed to server ONLY for Irys upload\n- Cleared from memory immediately after use\n- NEVER stored in database\n- Each request is isolated\n\n### 📊 Advantages:\n1. **Maximized server work** - Less complexity in n8n\n2. **User controls wallet** - Decentralized\n3. **Bidirectional** - Server prepares, n8n executes, server finalizes\n4. **Flexible** - Works with any wallet\n5. **Scalable** - Server handles heavy lifting\n\n### 🎯 Use Case:\nB2B clients can certify documents with minimal technical knowledge. Just provide SOL, workflow handles everything!",
        "height": 700,
        "width": 450,
        "color": 5
      },
      "id": "info",
      "name": "Architecture Info",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [240, 800]
    }
  ],
  "connections": {
    "When clicking 'Test workflow'": {
      "main": [[
        {
          "node": "Input Data",
          "type": "main",
          "index": 0
        }
      ]]
    },
    "Input Data": {
      "main": [[
        {
          "node": "1. Get Pricing",
          "type": "main",
          "index": 0
        }
      ]]
    },
    "1. Get Pricing": {
      "main": [[
        {
          "node": "2. Upload Document",
          "type": "main",
          "index": 0
        }
      ]]
    },
    "2. Upload Document": {
      "main": [[
        {
          "node": "3. Prepare Certification (Server)",
          "type": "main",
          "index": 0
        }
      ]]
    },
    "3. Prepare Certification (Server)": {
      "main": [[
        {
          "node": "4. Swap + Pay",
          "type": "main",
          "index": 0
        }
      ]]
    },
    "4. Swap + Pay": {
      "main": [[
        {
          "node": "5. Execute Irys Upload (Server)",
          "type": "main",
          "index": 0
        }
      ]]
    },
    "5. Execute Irys Upload (Server)": {
      "main": [[
        {
          "node": "6. Mint NFT (n8n)",
          "type": "main",
          "index": 0
        }
      ]]
    },
    "6. Mint NFT (n8n)": {
      "main": [[
        {
          "node": "7. Finalize (Server)",
          "type": "main",
          "index": 0
        }
      ]]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "1",
  "id": "photocertif-b2b-bidirectional",
  "meta": {
    "instanceId": "photocertif-b2b-bidirectional"
  },
  "tags": []
}
